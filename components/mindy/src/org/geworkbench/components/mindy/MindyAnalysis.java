package org.geworkbench.components.mindy;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.geworkbench.analysis.AbstractAnalysis;
import org.geworkbench.bison.datastructure.biocollections.microarrays.DSMicroarraySet;
import org.geworkbench.bison.datastructure.biocollections.microarrays.CSMicroarraySet;
import org.geworkbench.bison.datastructure.biocollections.views.DSMicroarraySetView;
import org.geworkbench.bison.datastructure.bioobjects.microarray.DSMicroarray;
import org.geworkbench.bison.datastructure.bioobjects.markers.DSGeneMarker;
import org.geworkbench.bison.datastructure.complex.panels.DSItemList;
import org.geworkbench.bison.model.analysis.AlgorithmExecutionResults;
import org.geworkbench.bison.model.analysis.ClusteringAnalysis;
import org.geworkbench.engine.management.Publish;
import org.geworkbench.engine.management.Subscribe;
import org.geworkbench.util.pathwaydecoder.mutualinformation.MindyDataSet;
import org.geworkbench.util.pathwaydecoder.mutualinformation.MindyData;
import org.geworkbench.builtin.projects.ProjectPanel;
import org.geworkbench.events.GeneSelectorEvent;
import org.geworkbench.util.threading.*;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.ArrayList;
import java.util.List;
import java.text.Collator;

import edu.columbia.c2b2.mindy.Mindy;
import edu.columbia.c2b2.mindy.MindyResults;
import wb.data.MicroarraySet;
import wb.data.Microarray;
import wb.data.MarkerSet;
import wb.data.Marker;

import javax.swing.JDialog;
import javax.swing.JButton;
import javax.swing.JProgressBar;
import javax.swing.JOptionPane;

/**
 * @author Matt Hall
 * @author ch2514
 * @version $ID$
 */
@SuppressWarnings("serial")
public class MindyAnalysis extends AbstractAnalysis implements ClusteringAnalysis {
    Log log = LogFactory.getLog(this.getClass());

    private MindyParamPanel paramPanel;
    private JDialog dialog;
    private JProgressBar progressBar;
    private JButton cancelButton;
    private Task task;
    private MindyDataSet mindyDataSet;

    /**
     * Constructor.
     * Creates MINDY parameter panel.
     */
    public MindyAnalysis() {
        setLabel("MINDY");
        paramPanel = new MindyParamPanel();
        setDefaultPanel(paramPanel);
    }

    
    // not used - required to implement from interface ClusteringAnalysis
    public int getAnalysisType() {
        return AbstractAnalysis.ZERO_TYPE;
    }
    

    /**
     * The execute method the framework calls to analyze parameters and create MINDY results.
     * 
     * @param input - microarray set data coming from the framework
     * @return analysis algorithm results
     */
    @SuppressWarnings("unchecked")
    public AlgorithmExecutionResults execute(Object input) {
        log.debug("input: " + input);
        // Use this to get params
        MindyParamPanel params = (MindyParamPanel) aspp;
        DSMicroarraySet<DSMicroarray> mSet = ((DSMicroarraySetView) input).getMicroarraySet();
        String paramDesc = "Generated by MINDY run with paramters: \n";
        
        int numMAs = mSet.size();
        paramDesc += "Number of microarrays: " + numMAs + "\n";
        if(numMAs < 4){
        	log.info("Not enough microarrays in the set. (Need at least 4)");
            JOptionPane.showMessageDialog(null, "Not enough microarrays in the set.  MINDY requires at least 4 microarrays.");
        	return null;
        }
        
        int numMarkers = mSet.getMarkers().size();
        paramDesc += "Number of markers: " + numMarkers + "\n";
        if(numMarkers < 2){
        	log.info("Not enough markers in the microarrays. (Need at least 2)");
            JOptionPane.showMessageDialog(null, "Not enough markers in the microarrays.  MINDY requires at least 2 markers in each microarray.");
        	return null;
        }
                
        paramDesc += "Candidate modulators: ";
        ArrayList<Marker> modulators = new ArrayList<Marker>();
        ArrayList<String> modulatorGeneList = params.getModulatorGeneList();
        for (String modGene : modulatorGeneList) {
            DSGeneMarker marker = mSet.getMarkers().get(modGene);
            if (marker == null) {
                log.info("Couldn't find marker " + modGene + " from modulator file in microarray set.");
                JOptionPane.showMessageDialog(null, modGene + " candidate modulator not found in loadad microarray set.");
                return null;
            } else {
                paramDesc += modGene + " ";
                modulators.add(new Marker(modGene));
            }
        }
        paramDesc += "\n";

        paramDesc += "DPI Annotated Genes: ";
        ArrayList<Marker> dpiAnnots = new ArrayList<Marker>();
        ArrayList<String> dpiAnnotList = params.getDPIAnnotatedGeneList();
        for (String modGene : dpiAnnotList) {
            DSGeneMarker marker = mSet.getMarkers().get(modGene);
            if (marker == null) {
                log.info("Couldn't find marker " + modGene + " from DPI annotation file in microarray set.");
                JOptionPane.showMessageDialog(null, modGene + " DPI annotated gene not found in loadad microarray set.");
                return null;
            } else {
                paramDesc += modGene + " ";
                dpiAnnots.add(new Marker(modGene));
            }
        }
        paramDesc += "\n";

        Mindy mindy = new Mindy();
        String transcriptionFactor = params.getTranscriptionFactor();
        DSGeneMarker transFac = mSet.getMarkers().get(transcriptionFactor);
        if (transFac == null) {
            JOptionPane.showMessageDialog(null, "Specified hub gene (" + transcriptionFactor + ") not found in loadad microarray set.");
            return null;
        }
        paramDesc += "Transcription Factor: " + transcriptionFactor + "\n";

        boolean fullSetMI = true;
        float fullSetThreshold = 0f;
        if (params.getFullSetMIThreshold() > 0) {
            fullSetThreshold = params.getFullSetMIThreshold();
            paramDesc += "Full Set MI Threshold: " + fullSetThreshold + "\n";
        } else {
            fullSetMI = false;
            fullSetThreshold = params.getFullsetPValueThreshold();
            paramDesc += "Full Set P-Value Threshold: " + fullSetThreshold + "\n";
        }

        boolean subsetMI = true;
        float subsetThreshold = 0f;
        if (params.getSubsetMIThreshold() > 0) {
            subsetThreshold = params.getSubsetMIThreshold();
            paramDesc += "Conditional MI Threshold: " + subsetThreshold + "\n";
        } else {
            subsetMI = false;
            subsetThreshold = params.getSubsetPValueThreshold();
            paramDesc += "Conditional P-Value Threshold: " + subsetThreshold + "\n";
        }

        float setFraction = params.getSetFraction() / 100f;
        paramDesc += "Set Fraction: " + setFraction + "\n";
        if(Math.round(setFraction * 2 * numMarkers) < 2){
        	log.info("Not enough markers in the specified % sample. (Need at least 2)");
            JOptionPane.showMessageDialog(null, "Not enough markers in the specified % sample.  MINDY requires at least 2 markers in the sample.");
        	return null;
        }
        
        // run Mindy algorithm in the background
        // and display an indeterminate progress bar in the foreground
        createProgressBarDialog();
        task = new Task(mindy
    			, params
    			, mSet
    			, modulators
    			, dpiAnnots
    			, fullSetMI
    			, fullSetThreshold
    			, subsetMI
    			, subsetThreshold
    			, setFraction
    			, transFac);        
        task.execute();     
        dialog.setVisible(true);        
        
        if(this.mindyDataSet != null){
	        ProjectPanel.addToHistory(this.mindyDataSet, paramDesc);
	        return new AlgorithmExecutionResults(true, "MINDY Results Loaded.", this.mindyDataSet);
        } else {
        	JOptionPane.showMessageDialog(paramPanel.getParent(), "Cannot analyze data.", "MINDY Analyze Error", JOptionPane.WARNING_MESSAGE);
        	return null;
        }

    }
    
    private void createProgressBarDialog(){
    	// lay the groundwork for the progress bar dialog
        dialog = new JDialog();
        progressBar = new JProgressBar();
        cancelButton = new JButton("Cancel");
        dialog.setLayout(new BorderLayout());
        dialog.setModal(true);
        dialog.setTitle("MINDY Process Running");
        dialog.setSize(300, 50);
        dialog.setLocation((int) (dialog.getToolkit().getScreenSize().getWidth() - dialog.getWidth()) / 2, (int) (dialog.getToolkit().getScreenSize().getHeight() - dialog.getHeight()) / 2);
        progressBar.setIndeterminate(true);
        dialog.add(progressBar, BorderLayout.CENTER);
        dialog.add(cancelButton, BorderLayout.EAST);
        
        cancelButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent actionEvent) {
            	if((task != null) && (!task.isCancelled()) && (!task.isDone())) {
            		task.cancel(true);
            		log.info("Cancelling Mindy Analysis");
            	}
            	dialog.setVisible(false);
            	dialog.dispose();            	
            }
        });

        dialog.addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent windowEvent) {
            	if((task != null) && (!task.isCancelled()) && (!task.isDone())){
            		task.cancel(true);
            		log.info("Cancelling Mindy Analysis");
            	}
            }
        });
    }

    

    /**
     * Receives GeneSelectorEvents from the framework (i.e. the Selector Panel)
     * @param e
     * @param source
     */
    @Subscribe public void receive(GeneSelectorEvent e, Object source) {
        DSGeneMarker marker = e.getGenericMarker(); // GeneselectorEvent can be a panel event therefore won't work here,
        if (marker != null) { //so added this check point--xuegong
            paramPanel.setTranscriptionFactor(marker.getLabel());
        }
    }

	/**
	 * Publish MINDY data to the framework.
	 * @param data
	 * @return
	 */
    @Publish
    public MindyDataSet publishMatrixReduceSet(MindyDataSet data) {
        return data;
    }
    
    /**
     * The swing worker class that runs Mindy analysis in the background.
     * @author ch2514
     * @version $Id: MindyAnalysis.java,v 1.19 2007-09-11 21:05:11 hungc Exp $
     */
    class Task extends SwingWorker<MindyDataSet, Void> {
    	private Mindy mindy;
    	private MindyParamPanel params;
    	private DSMicroarraySet<DSMicroarray> mSet;
    	private ArrayList<Marker> modulators;
    	private ArrayList<Marker> dpiAnnots;
    	private boolean fullSetMI;
    	private float fullSetThreshold;
    	private boolean subsetMI;
    	private float subsetThreshold;
    	private float setFraction;
    	private DSGeneMarker transFac;
    	
    	/**
    	 * Constructor.
    	 * Takes in all the arguments required to run the mindy algorithm.
    	 * 
    	 * @param mindy
    	 * @param params
    	 * @param mSet
    	 * @param modulators
    	 * @param dpiAnnots
    	 * @param fullSetMI
    	 * @param fullSetThreshold
    	 * @param subsetMI
    	 * @param subsetThreshold
    	 * @param setFraction
    	 * @param transFac
    	 */
    	public Task(Mindy mindy
    			, MindyParamPanel params
    			, DSMicroarraySet<DSMicroarray> mSet
    			, ArrayList<Marker> modulators
    			, ArrayList<Marker> dpiAnnots
    			, boolean fullSetMI
    			, float fullSetThreshold
    			, boolean subsetMI
    			, float subsetThreshold
    			, float setFraction
    			, DSGeneMarker transFac
    			){
    		this.mindy = mindy;
    		this.params = params;
    		this.mSet = mSet;
    		this.modulators = modulators;
    		this.dpiAnnots = dpiAnnots;
    		this.fullSetMI = fullSetMI;
    		this.fullSetThreshold = fullSetThreshold;
    		this.subsetMI = subsetMI;
    		this.subsetThreshold = subsetThreshold;
    		this.setFraction = setFraction;
    		this.transFac = transFac;
    	}
    	
    	/**
    	 * Runs Mindy analysis.
    	 * @return a mindy data set.  If the analysis fails, returns null.
    	 */
    	public MindyDataSet doInBackground(){
    		log.info("Running MINDY analysis.");
            MindyResults results=null;
            try{
            	log.info("Running MINDY algorithm. " + System.currentTimeMillis());
            	results = mindy.runMindy(convert(mSet), new Marker(params.getTranscriptionFactor()), modulators,
                    dpiAnnots, fullSetMI, fullSetThreshold, subsetMI, subsetThreshold,
                    setFraction, params.getDPITolerance());
            	log.info("Finished running MINDY algorithm. " + System.currentTimeMillis());
            } catch (Exception e){
            	log.error("Cannot analyze data.", e);            	
            	return null;
            }            
            log.info("MINDY analysis complete.  Converting Mindy results. " + System.currentTimeMillis());
            List<MindyData.MindyResultRow> dataRows = new ArrayList<MindyData.MindyResultRow>();
            Collator myCollator = Collator.getInstance();
            for (MindyResults.MindyResultForTarget result : results) {
                DSItemList<DSGeneMarker> markers = mSet.getMarkers();
                DSGeneMarker target = markers.get(result.getTarget().getName());
                for (MindyResults.MindyResultForTarget.ModulatorSpecificResult specificResult : result) {
                    DSGeneMarker mod = markers.get(specificResult.getModulator().getName());
                    dataRows.add(new MindyData.MindyResultRow(mod, transFac, target, specificResult.getScore(), 0f, myCollator.getCollationKey(mod.getShortName()), myCollator.getCollationKey(target.getShortName())));
                }
            }

            MindyData loadedData = new MindyData((CSMicroarraySet) mSet, dataRows, setFraction);
            MindyDataSet dataSet = new MindyDataSet(mSet, "MINDY Results", loadedData, params.getCandidateModulatorsFile());
            log.info("Done converting MINDY results. " + System.currentTimeMillis());
            
            return dataSet;
    	}
    	
    	/**
    	 * When the mindy analysis finishes, transfer the resulting mindy
    	 * data set back to the mindy analysis panel on the event thread.
    	 * Also disposes the progress bar dialog box.
    	 */
    	public void done(){
    		if(!this.isCancelled()){
	    		try{
	    			mindyDataSet = get();    			
	    			log.debug("Transferring mindy data set back to event thread.");
	    		} catch (Exception e) {
	    			log.error("Exception in finishing up worker thread that called MINDY: " + e.getMessage());
	    		}
    		}
    		dialog.setVisible(false);
    		dialog.dispose();
    		log.debug("Closing progress bar dialog.");
    	}
    	
    	private MicroarraySet convert(DSMicroarraySet<DSMicroarray> inSet) {
            MarkerSet markers = new MarkerSet();
            for (DSGeneMarker marker : inSet.getMarkers()) {
                markers.addMarker(new Marker(marker.getLabel()));
            }
            MicroarraySet returnSet = new MicroarraySet(inSet.getDataSetName(), "ID", "ChipType", markers);
            for (DSMicroarray microarray : inSet) {
                returnSet.addMicroarray(new Microarray(microarray.getLabel(), microarray.getRawMarkerData()));
            }
            return returnSet;
        }
    }
}

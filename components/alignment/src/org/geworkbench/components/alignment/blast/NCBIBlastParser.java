package org.geworkbench.components.alignment.blast;

/**
 *
 * @version $Id$
 */

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.StringTokenizer;
import java.util.Vector;

/**
 * BlastParser is a class that reads in from a text file generated by
 * RemoteBlast of Blast results. It parses out the Blast hits into a Vector of
 * BlastObj objects.
 */
public class NCBIBlastParser {

	private int totalSequenceNum = 0;
	private String filename;

	/**
	 * Creates a new BlastParser with querySeq and filename set to specified
	 * ProtSeq and String value. Also creates a new hits Vector.
	 * 
	 * @param the
	 *            ProtSeq to set querySeq to.
	 * @param the
	 *            String to set filename to.
	 */
	public NCBIBlastParser(final int totalSequenceNum, final String filename) {
		this.totalSequenceNum = totalSequenceNum;
		this.filename = filename;
	}

	final private static String NEWLINESIGN = "<BR>";
	final private static int HIT_NUMBER_LIMIT = 250;

	private int totalHitCount = 0;
	private boolean hitOverLimit = false;

	/**
	 * Reads in Blast results from file and parses data into BlastObj objects.
	 */
	public ArrayList<Vector<BlastObj>> parseResults() {
		/**
		 * The new BlastDataSet Array
		 */
		ArrayList<Vector<BlastObj>> blastDataset = new ArrayList<Vector<BlastObj>>(
				10);

		totalHitCount = 0;
		StringTokenizer st;
		BlastObj each;
		int index = 0;
		String subject = "";

		File file = new File(filename);
		// server failure
		if (file.length() < 600) {
			System.out.println("No hit found. try again.");
			return null;
		}
		try {
			BufferedReader br = new BufferedReader(new FileReader(filename));
			String line = br.readLine();
			int count = 0;
			do {
				// A Vector of Strings representing each Blast hit by Accession
				// number.
				Vector<BlastObj> hits = new Vector<BlastObj>();
				boolean hitsFound = false;
				// loop to proceed to beginning of hit list from Blast output
				// file
				while (line != null) {

					if (line
							.startsWith("Sequences producing significant alignments:")) {
						hitsFound = true;
						break;
					}
					if (line.contains("No significant similarity found.")) {
						hitsFound = false;
						break;
					}
					line = br.readLine();
				}
				if (!hitsFound) {
					count++;
					line = br.readLine();
					continue;
				}

				/* parsing section of the blast Hit info text */
				line = br.readLine();
				line = br.readLine();
				int hitCount = 0;
				while (line != null && !line.trim().startsWith("</pre>")) {

					String[] strA = line.split("</a>");

					hitCount++;
					totalHitCount++;
					if (hitCount > HIT_NUMBER_LIMIT) {
						hitOverLimit = true;
						line = br.readLine();
						continue; // skip further parsing the summary section
					}

					each = new BlastObj(); // create new BlastObj for hit
					if (strA.length < 3) {
						each.setRetriveWholeSeq(false);
					} else {
						each.setRetriveWholeSeq(true);
						StringTokenizer st1 = new StringTokenizer(strA[0], "\"");
						st1.nextToken();
						if (st1.hasMoreTokens()) {
							String s = st1.nextToken();
							each.setInfoURL(new URL(s));
							s = s.replaceAll("GenPept", "fasta");
							s = s.replaceAll("GenBank", "fasta");
							each.setSeqURL(new URL(s));

						}
						if (st1.hasMoreTokens()) {
							StringTokenizer st2 = new StringTokenizer(st1
									.nextToken(), "|");
							if (st2.hasMoreTokens()) {
								each
										.setDatabaseID(st2.nextToken()
												.substring(2));
							}
							if (st2.hasMoreTokens()) {
								each.setName(st2.nextToken());
							}
							if (st2.hasMoreTokens()) {
								each.setDescription(st2.nextToken());
							}
						}
						StringTokenizer st3 = new StringTokenizer(strA[1], "<");
						if (st3.hasMoreTokens()) {
							each.setDescription(st3.nextToken());
						}
						if (st3.hasMoreTokens()) {
							StringTokenizer st4 = new StringTokenizer(st3
									.nextToken(), ">");

							String str = "0";
							while (st4.hasMoreTokens()) {
								str = st4.nextToken();
							}
							each.setScore(new Float(str.trim()).intValue());
						}
						if (strA[2] != null) {
							String[] s = strA[2].split("<");
							each.setEvalue(s[0]);
						}

						hits.add(each);
					}

					line = br.readLine();
				} // end of processing summary.

				index = 0;

				boolean endofResult = false;
				while (line != null && !line.trim().startsWith("Database")
						&& !line.trim().startsWith(">")) {
					line = br.readLine();
				}

				/* parsing detailed alignments Each has <PRE></PRE> */
				while (line != null && line.trim().startsWith(">")
						|| line.trim().startsWith("Database")) {

					if (line.trim().startsWith("Database")) {
						endofResult = true;
						break;
					}

					String detaillines = "<PRE>" + line;
					line = br.readLine().trim();

					boolean additionalDetail = false;
					if (line.trim().startsWith("Score")) {
						index--;
						additionalDetail = true;

					}
					// get BlastObj hit for which alignment is for
					each = hits.get(index);
					// skip the beginning description
					subject = "";
					boolean getStartPoint = true;
					subject = "";
					int endPoint = 0;
					while (!(line.trim().startsWith(">"))) {

						if (line.startsWith("</form>")) {
							// end of the useful information for one blast.
							endofResult = true;
							break;
						}

						if (line.startsWith("Length=")) {
							String[] lengthVal = line.split("=");
							each.setLength(new Integer(lengthVal[1].trim())
									.intValue());
						}
						if (line.startsWith("Identities = ")) {
							/*
							 * TODO use Match pattern later.
							 */
							StringTokenizer st1 = new StringTokenizer(line, "(");
							st1.nextToken();
							String identity = st1.nextToken();
							String[] s = identity.split("%");
							each
									.setPercentAligned(new Integer(s[0])
											.intValue());

						}
						// get the start point, end point and length

						if (line.trim().startsWith("Sbjct")) {
							st = new StringTokenizer(line);
							st.nextToken();
							if (getStartPoint) {
								each.setStartPoint(Integer.valueOf(
										st.nextToken()).intValue());
								getStartPoint = false;
							} else {
								st.nextToken();
							}
							// concat the aligned parts and get rid of "-"
							subject = subject.concat(st.nextToken().replaceAll(
									"-", ""));

							endPoint = Integer.valueOf(st.nextToken())
									.intValue();
						}

						// System.out.println(each.getStartPoint() + "" +
						// each.getEndPoint());
						String s = br.readLine();
						line = s.trim();
						if (!line.startsWith(">")) {
							detaillines += s + NEWLINESIGN;
						}
					}
					each.setEndPoint(endPoint);
					each.setAlignmentLength(Math.abs(each.getStartPoint()
							- each.getEndPoint()) + 1);
					each.setSubject(subject);
					// System.out.println("sub" + subject);

					detaillines += "</PRE>";

					// System.out.println(detaillines);
					if (additionalDetail) {
						String previousDetail = each.getDetailedAlignment();
						detaillines = previousDetail + detaillines;
					}
					each.setDetailedAlignment(detaillines);

					index++;
					if (endofResult) {
						endofResult = false;
						break;
					}

				}
				line = br.readLine();

				blastDataset.add(hits);
				count++;
			} while (count < totalSequenceNum);
			return blastDataset;
		} catch (FileNotFoundException e) {
			System.out.println("file not found.");
			return null;
		} catch (IOException e) {
			System.out.println("NCBIBLASTParser + IOException!");
			return null;
		}

	}

	/**
	 * getSummary
	 * 
	 * @return String
	 */
	public String getSummary() {
		if (hitOverLimit) {
			return "Some sequences have more than 250 hits, only the first "
					+ HIT_NUMBER_LIMIT + " hits are displayed. Total hits are "
					+ totalHitCount + ".";
		}
		return "Total hits for all sequences are " + totalHitCount + ".";
	}

}
